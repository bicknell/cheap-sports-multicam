#!/usr/bin/env python3

import os
import argparse
import glob
from typing import List, Tuple

def collect_mp4_files(base_directory: str) -> List[List[str]]:
    """
    Collects MP4 files from subdirectories named 'cameraX' within a base directory,
    and returns them as a sorted list of lists of MP4 file paths.

    Args:
        base_directory (str): The root directory to search within.

    Returns:
        List[List[str]]: A list where each inner list contains full paths to MP4 files
                         found in a 'cameraX' subdirectory, sorted alphabetically.
                         The outer list is ordered by camera number (e.g., camera1's files first,
                         then camera2's files, and so on).
    """
    # List to store tuples of (camera_number, camera_name, full_path_to_dir) for sorting
    camera_dirs_info: List[Tuple[int, str, str]] = []

    # Check if the base directory exists
    if not os.path.isdir(base_directory):
        print(f"Error: Directory '{base_directory}' not found.")
        return []

    # Iterate through items in the base directory to find camera subdirectories
    for item_name in os.listdir(base_directory):
        item_path: str = os.path.join(base_directory, item_name)

        # Check if it's a directory and matches the 'cameraX' pattern
        if os.path.isdir(item_path) and item_name.startswith("camera"):
            camera_num_str: str = item_name[6:] # Extract the number part (e.g., "1", "2")
            if camera_num_str.isdigit():
                camera_num: int = int(camera_num_str)
                camera_dirs_info.append((camera_num, item_name, item_path))

    # Sort the camera directories by their numerical suffix
    camera_dirs_info.sort(key=lambda x: x[0])

    # List to store the final result: an array of arrays (List[List[str]])
    all_camera_mp4s: List[List[str]] = []

    # Process each sorted camera directory
    for camera_num, camera_name, camera_path in camera_dirs_info:
        # Find all .mp4 files within this camera directory
        mp4_files: List[str] = glob.glob(os.path.join(camera_path, "*.[Mm][Oo][Vv]"))
        # Sort the files alphabetically for consistent order
        sorted_mp4_files: List[str] = sorted(mp4_files)
        all_camera_mp4s.append(sorted_mp4_files)

    return all_camera_mp4s


def construct_ffmpeg_args(files: List[List[str]], one_audio: bool, output: str, encode: str = "YouTube") -> str:
    cmd: str = "ffmpeg \\\n"

    """
    ffmpeg wants the input files as a series of -i <filename>
    arguments.  To perform an offset to sync the video requires
    a -itsoffset argument.

    TODO: For now it prints an offset of 0.0 on cameras 2, 3, 4,
          and the user must edit the resulting CLI line.  This
          needs to be configurable somehow.
    """
    first = True
    for cam_list in files:
        if not first:
            cmd += '-itsoffset 0.0 '
        first = False
        for f in cam_list:
            cmd += f'-i {f} '
        cmd += '\\\n'

    """
    Construct a filter_complex filter that will combine the video.
    """
    cmd += '-filter_complex \\\n'

    """
    Construct a concat for each camera that combines the multiple
    files generated by the camera into one video and one audio 
    stream.

    TODO: If there is only one file a concat won't work and is unnecessary.
          Need to add handling for that case.
    """
    cmd += '    "'
    cam = 0
    n = 0
    first = True
    for cam_list in files:
        if not first:
            cmd += '     '
        first = False
        video = n
        for f in cam_list:
            cmd += f'[{video},v]'
            video += 1
        cmd += f'concat=n={len(cam_list)}:v=1:a=0[v{cam}_concat]; \\\n'
        cmd += '     '
        video = n
        for f in cam_list:
            cmd += f'[{video},a]'
            video += 1
        n = video
        cmd += f'concat=n={len(cam_list)}:v=0:a=1[a{cam}_concat]; \\\n'
        cam += 1

    """
    """
    cam = 0
    for cam_list in files:
        cmd += f'     [v{cam}_concat]scale=1920x1080,setpts=PTS-STARTPTS[scaled{cam}]; \\\n'
        cam += 1

    """
    Process the audio portion, here there are two choices.
    """
    if one_audio:
        """
        Output a single stereo stream.

        First output a volume adjustment line for each camera so the user can
        tweak the volume.

        Second combine the 4 adjusted audio streams into a single stereo stream.

        TODO: The user should be able to specify the volume adjustments at the 
              CLI or in a config file.
        """
        cam = 0
        for cam_list in files:
            cmd += f'     [a{cam}_concat]volume=1.0[a{cam}_adj]; \\\n';
            cam += 1
        cam = 0
        cmd += '     '
        for cam_list in files:
            cmd += f'[a{cam}_adj]'
            cam += 1
        cmd += f'amix=inputs={len(files)}:duration=longest:dropout_transition=2[aud_mix]; \\\n';

    """
    Tile the video in a 2x2 matrix.

    Stack the first two cameras left to right.
    Stack the second two cameras left to right.
    Stack the two stacks vertically.
    """
    cmd += '     [scaled0][scaled1]hstack[top]; \\\n'
    cmd += '     [scaled2][scaled3]hstack[bottom]; \\\n'
    cmd += '     [top][bottom]vstack[outv]" \\\n'

    """
    Send the final video to the output.
    """
    cmd += '-map "[outv]" \\\n'
    
    """
    Send the audio to the output.
    """
    if one_audio:
        """
        A single stereo stream.
        """
        cmd += '-map "[aud_mix]" \\\n'
    else:
        """
        All 4 audio streams individually.
        """
        cam = 0
        first = True
        for cam_list in files:
            if not first:
                cmd += ' '
            first = False
            cmd += f'-map "[a{cam}_adj]"'
            cam += 1
        cmd += ' \\\n'


    """
    How to encode the final video and audio:
        - -c:v libx264, aka H.264/MPEG-4 AVC
        - -preset veryfast
           - Other options: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow
           - Controls encoding speed, and resulting output file size.  Tweak down
             on faster / hardware accelerated computers.
        - -crf 21, aka Constant Rate Factor
           - 18-28 is generally acceptable.
           - Smaller values == larger files and more "quality"
        - -refs 4, aka Reference Frames
           - How many frames the encoder can look at, higher == smaller files but more CPU.
        - H.264 Profile "high"
           - Other options: baseline, main, high, high10, high442, high444
        - GOP size
           - I'm told 60 should work everywhere, and more may not work with some players.
        - B-frames between i/p-frames
           - I'm told 2 should work everywhere, and more may not work with some players.
        - Move the moov atom to the start of the file to allow immediate playback when streaming
        - -c:a aac, aka AAC-LC
        - -b:a, set audio bitrate to 192kbps

    TODO: Add more presets for different use cases.
    """
    if encode == 'YouTube':
        """
        I asked gemini.google.com for the best settings for uploading to YouTube.
        """
        cmd += '-c:v libx264 -preset veryfast -crf 21 -refs 4 -profile:v high -g 60 -bf 2 -movflags faststart \\\n'
        cmd += '-c:a aac -b:a 384k -ar 48000 -ac 2 \\\n'
    else:
        cmd += '-c:v libx264 -preset veryfast -crf 29 -qp 10 -profile:v main -vf format=yuv420p \\\n'
        cmd += '-c:a aac -b:a 192k \\\n'

    """
    Set the output file name.
    """
    cmd += f'{output}\n'

    return cmd


if __name__ == "__main__":
    # Set up argument parser
    parser: argparse.ArgumentParser = argparse.ArgumentParser(
        description="Collects MP4 file paths from 'cameraX' subdirectories."
    )
    parser.add_argument(
        "directory",
        type=str,
        help="The base directory to search for 'cameraX' subdirectories."
    )

    # Parse command-line arguments
    args: argparse.Namespace = parser.parse_args()
    input_directory: str = args.directory

    if len(input_directory) == 0:
        print("No input directory given.")
        os.exit(1)

    if not os.path.exists(input_directory):
        print(f"Directory {input_directory} does not exist.")
        os.exit(1)

    # Call the function to collect files
    # The return type is now List[List[str]]
    all_camera_mp4s: List[List[str]] = collect_mp4_files(input_directory)

    if all_camera_mp4s:
        command = construct_ffmpeg_args(all_camera_mp4s, True, input_directory + "/combined.mp4")
        print(command)
